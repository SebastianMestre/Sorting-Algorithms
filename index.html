<html>
	<head>
	</head>
	<body>
		<h1>Sorting Algorithms</h1>
		<ul>
			<li><a href="gapsort/index.html">gapsort</a></li>
			<li><a href="inplacemerge/index.html">in-place mergesort</a></li>
			<li><a href="lolaso/index.html">bad double selection sort</a></li>
			<li><a href="malosort/index.html">mergesort</a></li>
			<li><a href="maybesort/index.html">A really bad randomized sorting algorithm</a></li>
			<li><a href="median/index.html">median of array</a></li>
			<li><a href="pepesort/index.html">a slightly different in-place mergesort</a></li>
			<li><a href="quicksort/index.html">quicksort</a></li>
			<li><a href="shellsort/index.html">shellsort</a></li>
			<li><a href="smoothsort/index.html">smoothsort</a></li>
			<li><a href="weavesort/index.html">weavesort</a></li>
		</ul>
		<h2>What is this?</h2>
		<p>
			These are some sorting algorithms (and related) visualizations i've made between 2017 and 2019.
		</p>
		<p>
			Most of them are well-known algorithms (or are not sorting algorithms at all), there are only two original ones: the one I've named "Gapsort", and the one titled "a slightly different in-place mergesort". This last one I discovered by myself some time in 2018; soon after I found a better version of it online and ended up changing up the code somewhat, so what is shown on this repo is not quite what i discovered back then.
		</p>
		<p>
			More interestingly, I've come to know that my "gapsort" is a variation on a little-studied class of sorting algorithms known as "Library sorts", those being a variant of insertion sorts. I have not done much analysis on the run time complexity of my gapsort, but the literature sugests that a good library sort can be done in O(nlogn), and gapsort is very clearly (empirically determined) less than quadratic.
		</p>
	</body>
<html>
